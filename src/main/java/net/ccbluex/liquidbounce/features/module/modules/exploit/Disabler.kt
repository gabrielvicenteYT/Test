/*
 * LiquidBounce+ Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/WYSI-Foundation/LiquidBouncePlus/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.LiquidBounce
import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.features.module.modules.combat.KillAura
import net.ccbluex.liquidbounce.features.module.modules.movement.*
import net.ccbluex.liquidbounce.ui.client.hud.element.elements.Notification
import net.ccbluex.liquidbounce.ui.font.Fonts
import net.ccbluex.liquidbounce.utils.ClientUtils
import net.ccbluex.liquidbounce.utils.MovementUtils
import net.ccbluex.liquidbounce.utils.PacketUtils
import net.ccbluex.liquidbounce.utils.Rotation
import net.ccbluex.liquidbounce.utils.RotationUtils
import net.ccbluex.liquidbounce.utils.misc.RandomUtils
import net.ccbluex.liquidbounce.utils.render.Stencil
import net.ccbluex.liquidbounce.utils.render.RenderUtils
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.ccbluex.liquidbounce.value.*
import net.minecraft.client.gui.ScaledResolution
import net.minecraft.client.gui.inventory.GuiContainer
import net.minecraft.client.gui.inventory.GuiInventory
import net.minecraft.entity.player.PlayerCapabilities
import net.minecraft.network.handshake.client.C00Handshake
import net.minecraft.network.play.INetHandlerPlayClient
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.play.client.*
import net.minecraft.network.play.server.*
import io.netty.buffer.Unpooled
import net.minecraft.network.Packet
import net.minecraft.network.PacketBuffer
import net.minecraft.util.BlockPos
import net.minecraft.util.EnumFacing
import net.minecraft.world.WorldSettings.GameType

import java.awt.Color
import java.io.ByteArrayOutputStream
import java.io.DataOutputStream
import java.io.IOException
import java.util.LinkedList
import java.util.UUID

import kotlin.math.sqrt
import kotlin.math.round

@ModuleInfo(name = "Disabler", description = "Disable some anticheats' checks.", category = ModuleCategory.EXPLOIT)
class Disabler : Module() {

	val modeValue = ListValue("Mode", 
		arrayOf(
			"Basic", // cancel c0f and c00
			"FakeLag", // use a packet bus
			"SpartanCombat", // old spartan combat disabler
			"OldMatrix", // work with old matrix, around 5.2.x (with badly configured geysermc)
			"OldGhostly", // self-explanation
			"Kauri", // kauri
			"Riding", // spoof c0c packet with real player data
			"Spectate", // spoof c18 with player uid
			"SpectateV2", // spoof c18 with random uid
			"OldVerus", // Dort
			"MoonAC-Punishments", // simply detect fake demo packets and remove them, along with multiple guardians.
			"BlocksMC", // new version
			"PingSpoof", // ping spoof
			"Flag", // flag
			"Matrix", // re
			"Test" // based
		), "Basic")

	// FakeLag
	private val fakeLagMode = ListValue("FakeLag-Mode", arrayOf("All", "InBound", "OutBound"), "All", { modeValue.get().equals("fakelag", true) })

	private val minRand: IntegerValue = object : IntegerValue("FakeLag-MinDelay", 0, 0, 20000, { modeValue.get().equals("fakelag", true) }) {
        override fun onChanged(oldValue: Int, newValue: Int) {
            val v = maxRand.get()
            if (v < newValue) set(v)
        }
    }
    private val maxRand: IntegerValue = object : IntegerValue("FakeLag-MaxDelay", 0, 0, 20000, { modeValue.get().equals("fakelag", true) }) {
        override fun onChanged(oldValue: Int, newValue: Int) {
            val v = minRand.get()
            if (v > newValue) set(v)
        }
    }

	// PingSpoof (idfk what's this purpose but i will keep it here.)
	private val minpsf: IntegerValue = object : IntegerValue("PingSpoof-MinDelay", 0, 0, 10000, { modeValue.get().equals("pingspoof", true) }) {
        override fun onChanged(oldValue: Int, newValue: Int) {
            val v = maxpsf.get()
            if (v < newValue) set(v)
        }
    }
    private val maxpsf: IntegerValue = object : IntegerValue("PingSpoof-MaxDelay", 0, 0, 10000, { modeValue.get().equals("pingspoof", true) }) {
        override fun onChanged(oldValue: Int, newValue: Int) {
            val v = minpsf.get()
            if (v > newValue) set(v)
        }
    }
	private val psfStartSendMode = ListValue("PingSpoof-StartSendMode", arrayOf("All", "First"), "All", { modeValue.get().equals("pingspoof", true) })
	private val psfSendMode = ListValue("PingSpoof-SendMode", arrayOf("All", "First"), "All", { modeValue.get().equals("pingspoof", true) })
	private val psfWorldDelay = IntegerValue("PingSpoof-WorldDelay", 15000, 0, 30000, { modeValue.get().equals("pingspoof", true) })

	// flag
	private val flagMode = ListValue("Flag-Mode", arrayOf("Edit", "Packet"), "Edit", { modeValue.get().equals("flag", true) })
	private val flagTick = IntegerValue("Flag-TickDelay", 25, 1, 200, { modeValue.get().equals("flag", true) })

	// matrix
	val matrixNoCheck = BoolValue("Matrix-NoModuleCheck", false, { modeValue.get().equals("matrix", true) })

	// test
	val packetModify = BoolValue("Packet-Modification", false, { modeValue.get().equals("test", true) })
	val renderServer = BoolValue("Render-ServerSide", false, { modeValue.get().equals("test", true) })

	// debug
	private val debugValue = BoolValue("Debug", false)

	// variables
	private val keepAlives = arrayListOf<C00PacketKeepAlive>()
	private val transactions = arrayListOf<C0FPacketConfirmTransaction>()
	private val packetQueue = LinkedList<C0FPacketConfirmTransaction>()
	private val anotherQueue = LinkedList<C00PacketKeepAlive>()

	private val packetBus = hashMapOf<Long, Packet<INetHandlerPlayServer>>()
	private val queueBus = LinkedList<Packet<INetHandlerPlayServer>>()

	private val outBus = LinkedList<Packet<INetHandlerPlayServer>>()
	private val inBus = LinkedList<Packet<INetHandlerPlayClient>>()
	
	private val msTimer = MSTimer()

	private val inTimer = MSTimer()
	private val outTimer = MSTimer()

	private var alrSendY = false
	private var alrSprint = false

	private var expectedSetback = false

	private var sendDelay = 0
	private var inDelay = 0
	private var outDelay = 0
	private var shouldActive = false

	private var transCount = 0

	var shouldModifyRotation = false
	var customYaw = 0F

	private var verusLastY = 0.0

	val canModifyRotation: Boolean
		get() = (state && modeValue.get().equals("test", true) && shouldModifyRotation)

	val canRenderInto3D: Boolean
		get() = (state && modeValue.get().equals("test", true) && renderServer.get() && shouldModifyRotation)

	fun debug(s: String) {
		if (debugValue.get())
			ClientUtils.displayChatMessage("§7[§3§lDisabler§7]§f $s")
	}

	fun shouldRun(): Boolean = mc.thePlayer != null && mc.thePlayer.ticksExisted > 5
	fun isInventory(action: Short): Boolean = action > 0 && action < 100

	override val tag: String
        get() = modeValue.get()

	override fun onEnable() {
		keepAlives.clear()
		transactions.clear()
		packetQueue.clear()
		anotherQueue.clear()
		packetBus.clear()
		queueBus.clear()
		inBus.clear()
		outBus.clear()

		msTimer.reset()
		inTimer.reset()
		outTimer.reset()
		expectedSetback = false
		shouldActive = false
		alrSendY = false
		alrSprint = false
		transCount = 0

		shouldModifyRotation = false
		customYaw = 0F
	}

	override fun onDisable() {
		keepAlives.forEach {
			PacketUtils.sendPacketNoEvent(it)
		}
		transactions.forEach {
			PacketUtils.sendPacketNoEvent(it)
		}

		keepAlives.clear()
		transactions.clear()
		packetQueue.clear()
		anotherQueue.clear()
		packetBus.clear()

		if (modeValue.get().equals("pingspoof", true)) {
			// make sure not to cause weird flag
			for (p in queueBus)
				PacketUtils.sendPacketNoEvent(p)
		}
		queueBus.clear()

		msTimer.reset()

		mc.thePlayer.motionY = 0.0
		MovementUtils.strafe(0F)
		mc.timer.timerSpeed = 1F
	}

	@EventTarget
	fun onRender2D(event: Render2DEvent) {
		if (!shouldActive && modeValue.get().equals("pingspoof", true))
		{
			val sc = ScaledResolution(mc)
			val strength = (msTimer.hasTimeLeft(psfWorldDelay.get().toLong()).toFloat() / psfWorldDelay.get().toFloat()).coerceIn(0F, 1F)
			Stencil.write(true)
			RenderUtils.drawRoundedRect(sc.scaledWidth / 2F - 50F, 35F, sc.scaledWidth / 2F + 50F, 55F, 10F, Color(0, 0, 0, 140).rgb)
			Stencil.erase(true)
			RenderUtils.drawRect(sc.scaledWidth / 2F - 50F, 35F, sc.scaledWidth / 2F - 50F + 100F * strength, 55F, Color(0, 111, 255, 70).rgb)
			Stencil.dispose()
			Fonts.font40.drawCenteredString("${(msTimer.hasTimeLeft(psfWorldDelay.get().toLong()).toFloat() / 1000F).toInt()}s left...", sc.scaledWidth / 2F, 41F, -1)
		}
	}

	@EventTarget
	fun onPacket(event: PacketEvent) {
		val packet = event.packet
	
		when (modeValue.get().toLowerCase()) {
			"fakelag" -> {
				if (mc.thePlayer == null || mc.theWorld == null || mc.thePlayer.ticksExisted <= 0) return
				if ((fakeLagMode.get().equals("outbound", true) || fakeLagMode.get().equals("all", true)) && packet::class.java!!.getSimpleName().startsWith("C", true)) {
					debug("outbound")
					outBus.add(packet as Packet<INetHandlerPlayServer>)
					event.cancelEvent()
				}
				if ((fakeLagMode.get().equals("inbound", true) || fakeLagMode.get().equals("all", true)) && packet::class.java!!.getSimpleName().startsWith("S", true)) {
					debug("inbound")
					inBus.add(packet as Packet<INetHandlerPlayClient>)
					event.cancelEvent()
				}
			}
			"oldmatrix" -> if (packet is C03PacketPlayer && mc.thePlayer.ticksExisted % 15 == 0) {
				try {
					val b = ByteArrayOutputStream()
	                val _out = DataOutputStream(b)
	                _out.writeUTF(mc.thePlayer.gameProfile.getName())
	                val buf = PacketBuffer(Unpooled.buffer())
	                buf.writeBytes(b.toByteArray())
	                mc.netHandler.addToSendQueue(C17PacketCustomPayload("matrix:geyser", buf))

					debug("Sent Matrix Geyser spoof packet.")
				} catch (e: IOException) {
					debug("Error occurred.")
				}
			}
			"kauri" -> if (packet is C0FPacketConfirmTransaction) event.cancelEvent()
			"riding" -> if (packet is C03PacketPlayer) mc.netHandler.addToSendQueue(C0CPacketInput(mc.thePlayer.moveStrafing, mc.thePlayer.moveForward, mc.thePlayer.movementInput.jump, mc.thePlayer.movementInput.sneak))
			"basic" -> if (packet is C0FPacketConfirmTransaction || packet is C00PacketKeepAlive) event.cancelEvent()
			"oldghostly" -> {
				if (packet is C03PacketPlayer) mc.netHandler.addToSendQueue(C0CPacketInput())
				if (packet is C0FPacketConfirmTransaction || packet is C00PacketKeepAlive) event.cancelEvent()
			}
			"spartancombat" -> {
        		if (packet is C00PacketKeepAlive && (keepAlives.size <= 0 || packet != keepAlives[keepAlives.size - 1])) {
					debug("c00 added")
            		keepAlives.add(packet)
            		event.cancelEvent()
        		}
        		if (packet is C0FPacketConfirmTransaction && (transactions.size <= 0 || packet != transactions[transactions.size - 1])) {
					debug("c0f added")
            		transactions.add(packet)
            		event.cancelEvent()
        		}
			}
			"spectate" -> if (packet is C03PacketPlayer) mc.netHandler.addToSendQueue(C18PacketSpectate(mc.thePlayer.uniqueID))
			"spectatev2" -> if (packet is C03PacketPlayer) mc.netHandler.addToSendQueue(C18PacketSpectate(UUID.randomUUID()))
			"oldverus" -> {
				if (packet is C03PacketPlayer) {
					val yPos = round(mc.thePlayer.posY / 0.015625) * 0.015625
					mc.thePlayer.setPosition(mc.thePlayer.posX, yPos, mc.thePlayer.posZ)

					if (mc.thePlayer.ticksExisted % 45 == 0) {
						debug("flag")
						PacketUtils.sendPacketNoEvent(C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
            			PacketUtils.sendPacketNoEvent(C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY - 11.725, mc.thePlayer.posZ, false))
            			PacketUtils.sendPacketNoEvent(C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
					}
				}

				if (packet is S08PacketPlayerPosLook) {
					if (mc.thePlayer == null || mc.thePlayer.ticksExisted <= 0) return

					var x = packet.getX() - mc.thePlayer.posX
      				var y = packet.getY() - mc.thePlayer.posY
      				var z = packet.getZ() - mc.thePlayer.posZ
      				var diff = sqrt(x * x + y * y + z * z)
      				if (diff <= 8) {
        				event.cancelEvent()
        				PacketUtils.sendPacketNoEvent(C03PacketPlayer.C06PacketPlayerPosLook(packet.getX(), packet.getY(), packet.getZ(), packet.getYaw(), packet.getPitch(), true))

						debug("silent s08 accept")
      				}
				}

				if (packet is C0FPacketConfirmTransaction && !isInventory(packet.uid)) {
					repeat (4) {
						packetQueue.add(packet)
					}
					event.cancelEvent()
					debug("c0f dupe: 4x")
				}
			}
			"fakelag" -> {
				if (packet is C0FPacketConfirmTransaction && !isInventory(packet.uid)) {
					val expectedDelay = RandomUtils.nextInt(minRand.get(), maxRand.get())
					debug("transferred c0f to packet bus, delay: ${expectedDelay}ms")
					packetBus.put((System.currentTimeMillis() + expectedDelay).toLong(), packet)
					event.cancelEvent()
				}
				
				if (packet is C00PacketKeepAlive) {
					val expectedDelay = RandomUtils.nextInt(minRand.get(), maxRand.get())
					debug("transferred c00 to packet bus, delay: ${expectedDelay}ms")
					packetBus.put((System.currentTimeMillis() + expectedDelay).toLong(), packet)
					event.cancelEvent()
				}
			}
			"moonac-punishments" -> {
				if (packet is S2BPacketChangeGameState && ((packet.getGameState() == 5 && !mc.isDemo()) || packet.getGameState() == 10)) {
				// 5 = demo screen, 10 = guardian sound + animations
					event.cancelEvent()
					debug("found attempt to trigger ${if (packet.getGameState() == 5) "demo screen" else "guardian effects"}.")
				}

				if (packet is S02PacketChat && packet.getChatComponent() != null &&
				packet.getChatComponent().getUnformattedText().startsWith("GET TROLL", true))
					event.cancelEvent()
			}
			"blocksmc" -> {
				if (!shouldRun()) return

				if (packet is C0FPacketConfirmTransaction) {
					val action = packet.uid
					if (action.toInt() != -1 && isInventory(action))
						return
					
					event.cancelEvent()
					queueBus.add(packet)

					debug("detected non-vanilla c0f, transferred.")
				}

				if (packet is C00PacketKeepAlive) {
					event.cancelEvent()

					packet.key -= RandomUtils.nextInt(100, 1000)
					queueBus.add(packet)

					debug("detected c00, transferred.")
				}

				if (packet is C03PacketPlayer) {
					if (packet.isMoving()) {
						packet.onGround = (verusLastY == packet.y && mc.thePlayer.motionY <= 0)
					} else {
						packet.onGround = true
					}
					verusLastY = packet.y
					if (mc.thePlayer.ticksExisted % 120 == 0) {
						//expectedSetback = true

						packet.y -= 8.0
						packet.pitch = 90.05F
						packet.onGround = false
						//packet.rotating = false

						debug("editted c03 packet.")
					}
				}

				/*if (packet is S08PacketPlayerPosLook) {
					if (expectedSetback) { // with expected setback just cancel it
						expectedSetback = false
						event.cancelEvent()

						PacketUtils.sendPacketNoEvent(C03PacketPlayer.C06PacketPlayerPosLook(packet.getX(), packet.getY(), packet.getZ(), packet.getYaw(), packet.getPitch(), true))
						debug("expected teleport, silent setback.")
					} else {
						var x = packet.getX() - mc.thePlayer.posX
      					var y = packet.getY() - mc.thePlayer.posY
      					var z = packet.getZ() - mc.thePlayer.posZ
      					var diff = sqrt(x * x + y * y + z * z)
      					if (diff <= 8) {
        					event.cancelEvent()
        					PacketUtils.sendPacketNoEvent(C03PacketPlayer.C06PacketPlayerPosLook(packet.getX(), packet.getY(), packet.getZ(), packet.getYaw(), packet.getPitch(), true))

							debug("meet conditions, silent s08 accept")
	      				}
					}
				}*/
			}
			"flag" -> {
				if (packet is C03PacketPlayer && flagMode.get().equals("edit", true) && mc.thePlayer.ticksExisted > 0 && mc.thePlayer.ticksExisted % flagTick.get() == 0)
				{
					packet.setMoving(false)
					packet.y = -256.0

					debug("flagged")
				}
			}
			"pingspoof" -> {
				if (packet is C0FPacketConfirmTransaction && !isInventory(packet.uid)) {
					queueBus.add(packet)
					event.cancelEvent()

					debug("c0f added, action id ${packet.uid}, target id ${packet.windowId}")
				}
				if (packet is C00PacketKeepAlive) {
					queueBus.add(packet)
					event.cancelEvent()

					debug("c00 added, key ${packet.key}")
				}
			}
		}
	}

	fun flush(check: Boolean) {
		if ((if (check) psfSendMode.get() else psfStartSendMode.get()).equals("all", true)) 
			while (queueBus.size > 0) {
				PacketUtils.sendPacketNoEvent(queueBus.poll())
			}
		else
			PacketUtils.sendPacketNoEvent(queueBus.poll())
	}

	@EventTarget
	fun onWorld(event: WorldEvent) {
		transactions.clear()
		keepAlives.clear()
		packetQueue.clear()
		anotherQueue.clear()
		packetBus.clear()
		queueBus.clear()
		inBus.clear()
		outBus.clear()

		msTimer.reset()
		inTimer.reset()
		outTimer.reset()
		expectedSetback = false
		shouldActive = false
		alrSendY = false
		alrSprint = false
		transCount = 0
	}

	@EventTarget
	fun onMotion(event: MotionEvent) {
		shouldModifyRotation = false
		customYaw = mc.thePlayer.rotationYaw
		val killAura = LiquidBounce.moduleManager.getModule(KillAura::class.java)!! as KillAura
		val speed = LiquidBounce.moduleManager.getModule(Speed::class.java)!! as Speed
		val targetStrafe = LiquidBounce.moduleManager.getModule(TargetStrafe::class.java)!! as TargetStrafe
		if (modeValue.get().equals("test", true) && speed.state) { 
			if (targetStrafe.canStrafe) {
				customYaw = RotationUtils.getRotationsEntity(killAura.target!!).yaw + (if (targetStrafe.direction > 0) -90F else 90F)
				shouldModifyRotation = true

				debug("target strafe active, $customYaw")
				// no need to check for aura
			} else if (MovementUtils.isMoving()) {
				val expectRot = MovementUtils.getRawDirection()
				if (expectRot != customYaw) {
					customYaw = expectRot

					if (killAura.target == null) // check for aura
						RotationUtils.setTargetRotation(Rotation(customYaw, mc.thePlayer.rotationPitch))
					debug("strafe active, $customYaw")
				}
				shouldModifyRotation = true
			}
		}
	}

	@EventTarget
	fun onUpdate(event: UpdateEvent) {
		when (modeValue.get().toLowerCase()) {
			"fakelag" -> {
				if (!inBus.isEmpty() && inTimer.hasTimePassed(inDelay.toLong())) {
					while (inBus.size > 0) {
						inBus.poll().processPacket(mc.netHandler)
					}
					inDelay = RandomUtils.nextInt(minRand.get(), maxRand.get())
					inTimer.reset()
					debug("poll (in)")
				}
				if (!outBus.isEmpty() && outTimer.hasTimePassed(outDelay.toLong())) {
					while (outBus.size > 0) {
						PacketUtils.sendPacketNoEvent(outBus.poll())
					}
					outDelay = RandomUtils.nextInt(minRand.get(), maxRand.get())
					outTimer.reset()
					debug("poll (out)")
				}
			}
			"spartancombat" -> {
				if (msTimer.hasTimePassed(3000L) && keepAlives.size > 0 && transactions.size > 0) {
					PacketUtils.sendPacketNoEvent(keepAlives[keepAlives.size - 1])
					PacketUtils.sendPacketNoEvent(transactions[transactions.size - 1])

					debug("c00 no.${keepAlives.size - 1} sent.")
					debug("c0f no.${transactions.size - 1} sent.")
					keepAlives.clear()
					transactions.clear()
					msTimer.reset()
				}
			}
			"oldverus" -> {
				if (mc.thePlayer.ticksExisted % 180 == 0) {
      				while (packetQueue.size > 22) {
        				PacketUtils.sendPacketNoEvent(packetQueue.poll())
      				}
					debug("pushed queue until size < 22.")
    			}
			}
			"blocksmc" -> {
				if (!shouldRun()) {
					expectedSetback = false
					queueBus.clear()
					return
				}
				if (mc.thePlayer.ticksExisted % 120 == 0) {
					if (!queueBus.isEmpty()) {
						while (queueBus.size > 0) {
							val packet = queueBus.poll()
							val pType = if (packet is C00PacketKeepAlive) "c00" else "c0f"
							PacketUtils.sendPacketNoEvent(packet)

							debug("$pType poll.")
						}
					}
				}
			}
			"pingspoof" -> {
				if (msTimer.hasTimePassed(psfWorldDelay.get().toLong()) && !shouldActive) {
					shouldActive = true
					sendDelay = RandomUtils.nextInt(minpsf.get(), maxpsf.get())
					if (queueBus.size > 0) flush(false)
					msTimer.reset()
					debug("activated. expected next delay: ${sendDelay}ms")
				}

				if (shouldActive) {
					if (msTimer.hasTimePassed(sendDelay.toLong()) && !queueBus.isEmpty()) {
						flush(true)
						sendDelay = RandomUtils.nextInt(minpsf.get(), maxpsf.get())
						msTimer.reset()
						debug("expected next delay: ${sendDelay}ms")
					}
				}
			}
			"flag" -> {
				if (flagMode.get().equals("packet", true) && mc.thePlayer.ticksExisted > 0 && mc.thePlayer.ticksExisted % flagTick.get() == 0) {
					PacketUtils.sendPacketNoEvent(C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, -256.0, mc.thePlayer.posZ, mc.thePlayer.onGround))
					debug("flagged")
				}
			}
			"matrix" -> {
				if (matrixNoCheck.get() || (LiquidBounce.moduleManager.getModule(Fly::class.java)!!.state && !mc.thePlayer.onGround)) {
					for(i in 0..8) {
            			// find a empty inventory slot
            			if(mc.thePlayer.inventory.mainInventory[i] == null) {
                			mc.netHandler.addToSendQueue(C09PacketHeldItemChange(i))
                			break
            			}
        			
					PacketUtils.sendPacketNoEvent(C03PacketPlayer.C06PacketPlayerPosLook(0.0, 0.0, 0.0, 0F, 0F, false))}
					PacketUtils.sendPacketNoEvent(C03PacketPlayer.C06PacketPlayerPosLook(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, mc.thePlayer.rotationYaw, mc.thePlayer.rotationPitch, true))
                    mc.netHandler.addToSendQueue(C08PacketPlayerBlockPlacement(BlockPos(-1, -1, -1), -1, null, 0f, 0f, 0f))
				}
			}
		}
	}
}
